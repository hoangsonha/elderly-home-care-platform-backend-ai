name: Deploy to VPS

on:
  push:
    branches:
      - main      # Deploy khi push vÃ o main branch
      - master    # Hoáº·c master branch
  workflow_dispatch:  # Cho phÃ©p cháº¡y manual tá»« GitHub UI

jobs:
  deploy:
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Deploy to VPS via SSH
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.VPS_HOST }}
          username: ${{ secrets.VPS_USERNAME }}
          key: ${{ secrets.VPS_SSH_KEY }}
          port: ${{ secrets.VPS_PORT || 22 }}
          debug: true
          script_stop: false  # â¬…ï¸ CHANGED: Don't stop on non-critical errors
          script: |
            set -e  # Exit on error
            
            echo ""
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘           ğŸš€ Starting Deployment to VPS                      â•‘"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            
            # Detect docker-compose command (v1 or v2)
            echo "ğŸ” [STEP 1/8] Detecting Docker Compose version..."
            if command -v docker-compose &> /dev/null; then
              DOCKER_COMPOSE="docker-compose"
            elif docker compose version &> /dev/null; then
              DOCKER_COMPOSE="docker compose"
            else
              echo "âŒ Error: docker-compose not found!"
              exit 1
            fi
            echo "âœ… Using: $DOCKER_COMPOSE"
            echo ""
            
            # Navigate to project directory
            echo "ğŸ“‚ [STEP 2/9] Navigating to project directory..."
            cd ~/elderly-home-care-platform-backend-ai || { echo "âŒ Directory not found!"; exit 1; }
            echo "âœ… Current directory: $(pwd)"
            echo ""
            
            # Protect SSH authorized_keys (backup and restore if needed)
            echo "ğŸ” [STEP 3/9] Protecting SSH authorized_keys..."
            SSH_DIR="$HOME/.ssh"
            SSH_KEY_FILE="$SSH_DIR/authorized_keys"
            SSH_BACKUP_FILE="$PWD/.ssh_authorized_keys_backup"
            
            # Create .ssh directory if it doesn't exist
            mkdir -p "$SSH_DIR"
            
            # Backup existing authorized_keys if it exists and has content
            if [ -f "$SSH_KEY_FILE" ] && [ -s "$SSH_KEY_FILE" ]; then
              echo "   ğŸ“‹ Backing up existing authorized_keys..."
              cp "$SSH_KEY_FILE" "$SSH_BACKUP_FILE" 2>/dev/null || true
              echo "   âœ… Backup created"
            elif [ -f "$SSH_BACKUP_FILE" ] && [ -s "$SSH_BACKUP_FILE" ]; then
              echo "   âš ï¸  authorized_keys missing, restoring from backup..."
              cp "$SSH_BACKUP_FILE" "$SSH_KEY_FILE" 2>/dev/null || true
              chmod 600 "$SSH_KEY_FILE" 2>/dev/null || true
              echo "   âœ… Restored from backup"
            else
              echo "   âš ï¸  No authorized_keys found and no backup available"
              echo "   â„¹ï¸  Please add SSH key manually: echo 'PUBLIC_KEY' > ~/.ssh/authorized_keys"
            fi
            
            # Ensure correct permissions
            chmod 700 "$SSH_DIR" 2>/dev/null || true
            if [ -f "$SSH_KEY_FILE" ]; then
              chmod 600 "$SSH_KEY_FILE" 2>/dev/null || true
            fi
            echo "âœ… SSH protection completed"
            echo ""
            
            # Determine current branch (if exists) or use default
            CURRENT_BRANCH=$(git branch --show-current 2>/dev/null || echo "main")
            echo "ğŸŒ¿ Git Branch: $CURRENT_BRANCH"
            echo ""
            
            # Pull latest code from GitHub
            echo "â¬‡ï¸  [STEP 4/9] Pulling latest code from GitHub..."
            git fetch origin
            if git pull origin $CURRENT_BRANCH || git pull origin main || git pull origin master; then
              echo "âœ… Code updated successfully"
            else
              echo "âš ï¸  Git pull failed, continuing with existing code..."
            fi
            echo ""
            
            # Backup database before deployment
            echo "ğŸ’¾ [STEP 5/9] Creating Database Backup..."
            BACKUP_DIR="$PWD/backups"
            mkdir -p "$BACKUP_DIR"
            echo "ğŸ“ Backup directory: $BACKUP_DIR"
            
            # Check if database container is running
            if docker ps | grep -q elderly_db; then
              BACKUP_FILE="$BACKUP_DIR/db_backup_$(date +%Y%m%d_%H%M%S).sql"
              echo "ğŸ”„ Creating backup: $(basename $BACKUP_FILE)"
              
              # Create backup using pg_dump
              if docker exec elderly_db pg_dump -U postgres elderly_platform > "$BACKUP_FILE" 2>/dev/null; then
                if [ -f "$BACKUP_FILE" ] && [ -s "$BACKUP_FILE" ]; then
                  # Compress backup to save space
                  if gzip -f "$BACKUP_FILE" 2>/dev/null; then
                    BACKUP_FILE="${BACKUP_FILE}.gz"
                    BACKUP_SIZE=$(ls -lh "$BACKUP_FILE" | awk '{print $5}')
                    echo "âœ… Backup created successfully!"
                    echo "   ğŸ“¦ File: $(basename $BACKUP_FILE)"
                    echo "   ğŸ“Š Size: $BACKUP_SIZE"
                    
                    # Keep only last 10 backups (cleanup old backups)
                    echo "ğŸ§¹ Cleaning up old backups (keeping last 10)..."
                    (set +e; \
                     cd "$BACKUP_DIR" 2>/dev/null || exit 0; \
                     BACKUP_FILES=($(ls -t db_backup_*.sql.gz 2>/dev/null || true)); \
                     if [ ${#BACKUP_FILES[@]} -gt 10 ]; then \
                       REMOVE_FILES=("${BACKUP_FILES[@]:10}"); \
                       echo "   ğŸ—‘ï¸  Removing ${#REMOVE_FILES[@]} old backup(s)..."; \
                       rm -f "${REMOVE_FILES[@]}" 2>/dev/null || true; \
                       echo "   âœ… Old backups cleaned up"; \
                     else \
                       echo "   â„¹ï¸  No old backups to remove (only ${#BACKUP_FILES[@]} backup(s))"; \
                     fi)
                  else
                    echo "âš ï¸  Warning: Could not compress backup"
                  fi
                else
                  echo "âš ï¸  Warning: Backup file is empty"
                fi
              else
                echo "âš ï¸  Warning: Could not create backup (database might not be accessible)"
              fi
            else
              echo "âš ï¸  Database container is not running, skipping backup"
            fi
            echo ""
            
            # Stop existing containers (gracefully, don't remove volumes)
            echo "ğŸ›‘ [STEP 6/9] Stopping existing containers..."
            echo "   â„¹ï¸  Note: Volumes will be preserved (database data safe)"
            if $DOCKER_COMPOSE down; then
              echo "âœ… Containers stopped successfully"
            else
              echo "â„¹ï¸  No containers were running"
            fi
            echo ""
            
            # Rebuild and start containers
            echo "ğŸ”¨ [STEP 7/9] Building containers..."
            echo "   â„¹ï¸  Building only changed services (using cache when possible)..."
            echo "   â³ This may take several minutes if dependencies changed..."
            if $DOCKER_COMPOSE build; then
              echo "âœ… Build completed successfully"
            else
              echo "âŒ Build failed!"
              exit 1
            fi
            echo ""
            
            echo "ğŸš€ [STEP 8/9] Starting containers..."
            if $DOCKER_COMPOSE up -d; then
              echo "âœ… Containers started successfully"
            else
              echo "âŒ Start failed!"
              exit 1
            fi
            echo ""
            
            # Wait for services to be ready
            echo "â³ Waiting for services to be ready (15 seconds)..."
            sleep 15
            echo "âœ… Wait completed"
            echo ""
            
            # Check container status
            echo "ğŸ“Š [STEP 9/9] Checking deployment status..."
            
            # Final SSH key backup check
            echo "ğŸ” Final SSH key protection check..."
            if [ -f "$SSH_KEY_FILE" ] && [ -s "$SSH_KEY_FILE" ]; then
              # Ensure backup is up to date
              cp "$SSH_KEY_FILE" "$SSH_BACKUP_FILE" 2>/dev/null || true
              echo "   âœ… SSH authorized_keys is safe"
            else
              echo "   âš ï¸  WARNING: authorized_keys is missing or empty!"
              echo "   ğŸ’¡ Restore from backup manually if needed"
            fi
            echo ""
            echo ""
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“¦ CONTAINER STATUS"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            $DOCKER_COMPOSE ps
            echo ""
            
            # Check if all containers are running
            set +e  # Temporarily disable exit on error
            EXIT_COUNT=$($DOCKER_COMPOSE ps 2>/dev/null | grep -c "Exit" 2>/dev/null || echo "0")
            EXIT_COUNT=$(echo "$EXIT_COUNT" | tr -d '[:space:]' | head -1)
            if ! [[ "$EXIT_COUNT" =~ ^[0-9]+$ ]]; then
              EXIT_COUNT=0
            fi
            
            if [ "$EXIT_COUNT" -gt 0 ]; then
              echo "âš ï¸  WARNING: Some containers failed to start!"
              $DOCKER_COMPOSE ps
              echo ""
              set -e  # Re-enable exit on error
              exit 1  # Fail the deployment if containers didn't start
            else
              echo "âœ… All containers are running"
              echo ""
            fi
            set -e  # Re-enable exit on error
            
            # Show recent logs
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "ğŸ“ RECENT LOGS (last 30 lines)"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            $DOCKER_COMPOSE logs --tail=30
            echo ""
            
            # Health check (optional - test backend endpoint)
            # â¬‡ï¸ FIXED: Don't fail script if health check fails
            echo "ğŸ¥ HEALTH CHECK"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            sleep 5
            set +e  # Disable exit on error for health check
            if curl -f http://localhost:8080/v3/api-docs > /dev/null 2>&1; then
              echo "âœ… Backend is responding (HTTP 200)"
            else
              echo "âš ï¸  Backend health check failed (might still be starting up)"
              echo "   â„¹ï¸  This is normal - backend may need more time to initialize"
            fi
            set -e  # Re-enable exit on error
            echo ""
            
            echo "â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—"
            echo "â•‘              âœ… DEPLOYMENT COMPLETED SUCCESSFULLY!            â•‘"
            echo "â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
            echo ""
            echo "ğŸ“Œ Summary:"
            echo "   â€¢ Database data preserved in Docker volume"
            echo "   â€¢ All containers rebuilt and restarted"
            echo "   â€¢ Services should be accessible shortly"
            echo "   â€¢ Check logs with: docker compose logs -f"
            echo ""